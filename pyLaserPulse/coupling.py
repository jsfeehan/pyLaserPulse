#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Nov 23 16:06:13 2020

@author: james feehan

Module of general functions for calculating propagation parameters.
"""
import numpy as np

import pyLaserPulse.abstract_bases as bases
import pyLaserPulse.utils as utils


class fibreToFibreCoupling(bases.coupling_transmission_base):
    """
    Class for handling the transmission loss between two spliced fibres.
    """

    def __init__(self, grid, comp1, comp2, name_list_1, name_list_2):
        """
        Parameters
        ----------
        grid : pyLaerPulse grid object.
        comp_1 : first component object
        comp_2 : second component object
        name_list_1 : list
            Generated by optical_assemblies.py
            Names populating the list are obtained as follows:
            comp_1.__class__.__name__, comp_1.__class__.__bases__.__name__, ...
        name_list_2 : list
            Names generated by optical_assemblies.py
            Names populating the list are obtained as follows:
            comp_2.__class__.__name__, comp_2.__class__.__bases__.__name__, ...
        """
        super().__init__(grid)
        try:
            # step_index_fibre to step_index_fibre (passive or active)
            self._make_transmission_spectrum(
                comp1.effective_MFD, comp2.effective_MFD)
        except AttributeError:
            types = ('fibre_component', 'fibre_pulse_picker')
            # loss between fibre_components/fibre_pulse_pickers
            c1 = any(comp in name for name in name_list_1 for comp in types)
            c2 = any(comp in name for name in name_list_2 for comp in types)
            if c1 and c2:
                self._make_transmission_spectrum(
                    comp1.output_fibre.effective_MFD,
                    comp2.input_fibre.effective_MFD)
            # loss between fibre_component/fibre_pulse_picker and fibre
            elif c1:
                self._make_transmission_spectrum(
                    comp1.output_fibre.effective_MFD, comp2.effective_MFD)
            # loss between fibre and fibre_component/fibre_pulse_picker
            elif c2:
                self._make_transmission_spectrum(
                    comp1.effective_MFD, comp2.input_fibre.effective_MFD)

    def _make_transmission_spectrum(self, MFD_1, MFD_2):
        """
        Calculate splice transmission between two fibres with arbitrary MFD.

        Parameters
        ----------
        MFD_1 : numpy array
            Mode field diameter as a function of wavelength for component 1
        MFD_2 : numpy array
            Mode field diameter as a function of wavelength for component 2

        Notes
        -----
        This method uses the equation for splice loss between two fibres with
        an axial offset* chosen to match Fujikura's specification for the
        typical loss between two identical lengths of SMF (0.03 dB). The offset
        giving this loss was found to be mean(MFD_1, MFD_2) / 12. Angular
        offset is not taken into account because the mode properties for the
        axial equations used here are not required, and also because equations
        for losses associated with tilt and displacement have the same form.

        *D. Marcuse, "Loss analysis of single mode fibre splices", Bell Systems
        Technical Journal 56(5), 1977.
        """
        # Marcuse formula giving typical loss for Fujikura SMF->SMF splice.
        d = 0.5 * (MFD_1 + MFD_2) / 12
        numerator = 2 * MFD_1 * MFD_2
        denominator = MFD_1**2 + MFD_2**2
        self.transmission_spectrum = \
            (numerator / denominator)**2 * np.exp(-2 * d**2 / denominator)
        self.transmission_spectrum = utils.fftshift(self.transmission_spectrum)


class freeSpaceToFibreCoupling(bases.coupling_transmission_base):
    """
    Class for handling the transmission loss between free-space and fibre
    components.
    """

    def __init__(self, grid, comp):
        """
        Parameters
        ----------
        grid : pyLaerPulse grid object.
        comp : Component object.
        """
        super().__init__(grid)
        # Possibly include mode-dependent coupling loss later on.
        # Used to have an approximation of this using fibre/fibre couling
        # loss and a mismatched MFD, but this is not general enough to be
        # useful.
        # For now, just use Fresnel loss.
        self._make_transmission_spectrum(1.0003, comp.signal_ref_index)

    def _make_transmission_spectrum(self, ref_index_1, ref_index_2):
        """
        Calculate the transmission at the interface between two refractive
        indices.

        Parameters
        ----------
        ref_index_1 : numpy array
            Refractive index as a function of wavelength for component 1
        ref_index_2 : numpy array
            Refractive index as a function of wavelength for component 2

        Notes
        -----
        Approximation with no polarization dependence. Reasonably accurate for
        air/silica boundaries up to an incidence angle of ~10 degrees from
        normal, so adequate for angled cleaves.
        """
        numerator = ref_index_1 - ref_index_2
        denominator = ref_index_1 + ref_index_2
        self.transmission_spectrum = 1 - (numerator / denominator)**2
        self.transmission_spectrum = utils.fftshift(self.transmission_spectrum)
